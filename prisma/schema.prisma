generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  id                        BigInt    @id @default(autoincrement()) @db.UnsignedBigInt
  name                      String    @db.VarChar(255)
  login                     String    @unique(map: "users_login_unique") @db.VarChar(255)
  email                     String    @unique(map: "users_email_unique") @db.VarChar(255)
  phone                     String    @unique(map: "users_phone_unique") @db.VarChar(255)
  birthday                  String?   @db.VarChar(255)
  email_verified_at         DateTime? @db.Timestamp(0)
  password                  String    @db.VarChar(255)
  two_factor_secret         String?   @db.Text
  two_factor_recovery_codes String?   @db.Text
  two_factor_confirmed_at   DateTime? @db.Timestamp(0)
  remember_token            String?   @db.VarChar(100)
  current_team_id           BigInt?   @db.UnsignedBigInt
  profile_photo_path        String?   @db.VarChar(2048)
  profile                   String    @default("user")
  bep20_address             String?   @db.VarChar(255)
  bep20_public_key          String?   @db.VarChar(255)
  bep20_private_key         String?   @db.VarChar(255)
  last_login                DateTime? @db.DateTime(0)
  last_login_ip             String?   @db.VarChar(45)
  country_code              String?   @db.VarChar(255)
  country_name              String?   @db.VarChar(255)

  sponsor    User?   @relation("sponsor", fields: [sponsor_id], references: [id])
  sponsor_id BigInt? @db.UnsignedBigInt

  binary_parent_id BigInt?         @db.UnsignedBigInt
  position         users_position?
  is_active        Boolean         @default(false)

  created_at DateTime? @default(now())
  updated_at DateTime? @updatedAt

  users_users_binary_parent_idTousers       User?  @relation("users_binary_parent_idTousers", fields: [binary_parent_id], references: [id], onUpdate: Restrict, map: "users_binary_parent_id_foreign")
  other_users_users_binary_parent_idTousers User[] @relation("users_binary_parent_idTousers")
  users_users_sponsor_idTousers             User?  @relation("users_sponsor_idTousers", fields: [sponsor_id], references: [id], onUpdate: Restrict, map: "users_sponsor_id_foreign")
  other_users_users_sponsor_idTousers       User[] @relation("users_sponsor_idTousers")

  User                  User[]                  @relation("sponsor")
  StrategyBinary        StrategyBinary[]        @relation("user")
  UserSession           UserSession[]           @relation("user")
  Order                 Order[]                 @relation("user")
  OrderItemDistribution OrderItemDistribution[] @relation("user")
  StrategyProgress      StrategyProgress[]      @relation("user")
  Balance               Balance[]               @relation("user")
  BalanceHistory        BalanceHistory[]        @relation("user")

  @@index([binary_parent_id], map: "users_binary_parent_id_foreign")
  @@index([sponsor_id], map: "users_sponsor_id_foreign")
  @@map("users")
}

model Balance {
  user    User       @relation("user", fields: [user_id], references: [id])
  user_id BigInt     @db.UnsignedBigInt
  wallet  WalletType @default(MAIN)
  amount  Decimal

  created_at DateTime? @default(now())
  updated_at DateTime? @updatedAt

  @@id(name: "balanceId", [user_id, wallet])
  @@unique([user_id, wallet])
  @@map("balance")
}

model BalanceHistory {
  id        Int                  @id @default(autoincrement())
  name      String?
  user      User                 @relation("user", fields: [user_id], references: [id])
  user_id   BigInt               @db.UnsignedBigInt
  wallet    WalletType           @default(MAIN)
  direction BalanceDirectionType
  amount    Decimal

  ref_type String?
  ref_id   BigInt?

  created_at DateTime? @default(now())
  updated_at DateTime? @updatedAt

  @@map("balance_history")
}

model PasswordResetToken {
  email String @id @db.VarChar(255)
  token String @db.VarChar(255)

  created_at DateTime? @default(now())
  updated_at DateTime? @updatedAt

  @@map("password_reset_tokens")
}

/// The underlying table does not contain a valid unique identifier and can therefore currently not be handled by Prisma Client.
model PasswordReset {
  id    BigInt @id @default(autoincrement()) @db.UnsignedBigInt
  email String @db.VarChar(255)
  token String @db.VarChar(255)

  created_at DateTime? @default(now())
  updated_at DateTime? @updatedAt

  @@index([email], map: "password_resets_email_index")
  @@map("password_resets")
}

model PersonalAccessToken {
  id             BigInt    @id @default(autoincrement()) @db.UnsignedBigInt
  tokenable_type String    @db.VarChar(255)
  tokenable_id   BigInt    @db.UnsignedBigInt
  name           String    @db.VarChar(255)
  token          String    @unique(map: "personal_access_tokens_token_unique") @db.VarChar(64)
  abilities      String?   @db.Text
  last_used_at   DateTime? @db.Timestamp(0)
  expires_at     DateTime? @db.Timestamp(0)

  created_at DateTime? @default(now())
  updated_at DateTime? @updatedAt

  @@index([tokenable_type, tokenable_id], map: "personal_access_tokens_tokenable_type_tokenable_id_index")
  @@map("personal_access_tokens")
}

model Product {
  id                    BigInt              @id @default(autoincrement()) @db.UnsignedBigInt
  name                  String              @db.VarChar(100)
  description           String?             @db.Text
  price                 Decimal             @db.Decimal(10, 2)
  direct_bonus          Boolean?
  direct_bonus_yield    Decimal?            @db.Decimal(5, 4)
  yield_type            products_yield_type @default(diary)
  yield                 Decimal             @db.Decimal(10, 7)
  unilevel_bonus        Boolean?            @default(false)
  unilevel_bonus_yields String?             @db.LongText

  category    Category? @relation(fields: [category_id], references: [id])
  category_id BigInt?   @db.UnsignedBigInt

  created_at DateTime? @default(now())
  updated_at DateTime? @updatedAt

  OrderItem OrderItem[] @relation("product")

  @@map("products")
}

model Category {
  id   BigInt @id @default(autoincrement()) @db.UnsignedBigInt
  name String @db.VarChar(100)

  direct_bonus        Boolean?
  direct_bonus_yield  Decimal? @db.Decimal(5, 4)
  direct_bonus_levels Int?

  unilevel_bonus        Boolean? @default(false)
  unilevel_bonus_yields Decimal? @db.Decimal(10, 4)
  unilevel_bonus_levels Int?

  residual_bonus        Boolean?
  residual_bonus_yield  Decimal? @db.Decimal(10, 4)
  residual_bonus_levels Int?

  binary_bonus               Boolean? @default(false)
  binary_bonus_yields        Decimal? @db.Decimal(10, 4)
  binary_bonus_point_percent Decimal? @db.Decimal(10, 4)
  binary_bonus_levels        Int?

  CategoryItem CategoryItem[]

  created_at DateTime? @default(now())
  updated_at DateTime? @updatedAt

  Product Product[]

  @@map("categories")
}

model CategoryItem {
  id           BigInt             @id @default(autoincrement()) @db.UnsignedBigInt
  type         StrategyConfigType
  category     Category           @relation(fields: [category_id], references: [id])
  category_id  BigInt             @db.UnsignedBigInt
  max_value    Decimal?           @db.Decimal(10, 2)
  level_values Json

  created_at DateTime? @default(now())
  updated_at DateTime? @updatedAt

  @@unique([type, category_id, max_value])
  @@map("category_items")
}

model UserSession {
  id           BigInt  @id @default(autoincrement()) @db.UnsignedBigInt
  access_token String  @db.LongText
  ip_address   String? @db.VarChar(45)

  user    User?   @relation("user", fields: [user_id], references: [id])
  user_id BigInt? @db.UnsignedBigInt

  status user_session @default(active)

  created_at DateTime? @default(now())
  updated_at DateTime? @updatedAt

  @@map("user_session")
}

model Session {
  id      String  @id @db.VarChar(255)
  user_id BigInt? @db.UnsignedBigInt

  ip_address    String? @db.VarChar(45)
  user_agent    String? @db.Text
  payload       String  @db.LongText
  last_activity Int

  @@index([last_activity], map: "sessions_last_activity_index")
  @@index([user_id], map: "sessions_user_id_index")
  @@map("sessions")
}

model StrategyBinary {
  id      BigInt  @id @default(autoincrement()) @db.UnsignedBigInt
  user    User?   @relation("user", fields: [user_id], references: [id])
  user_id BigInt? @db.UnsignedBigInt

  ref           String @default("")
  hier          String @db.LongText()
  level         Int    @default(0)
  autoDirection String @default("L")

  parent    StrategyBinary? @relation("parent", fields: [parent_id], references: [id])
  parent_id BigInt?         @db.UnsignedBigInt

  left       StrategyBinary? @relation("left", fields: [left_id], references: [id])
  left_id    BigInt?         @db.UnsignedBigInt
  left_count BigInt          @default(0)
  left_point BigInt          @default(0)

  right       StrategyBinary? @relation("right", fields: [right_id], references: [id])
  right_id    BigInt?         @db.UnsignedBigInt
  right_count BigInt          @default(0)
  right_point BigInt          @default(0)

  created_at DateTime? @default(now())
  updated_at DateTime? @updatedAt

  ParentStrategyBinary StrategyBinary[] @relation("parent")
  LeftStrategyBinary   StrategyBinary[] @relation("left")
  RightStrategyBinary  StrategyBinary[] @relation("right")

  @@map("strategy_binary")
}

model StrategyConfig {
  id      BigInt             @id @default(autoincrement()) @db.UnsignedBigInt
  type    StrategyConfigType
  level   Int
  value   Decimal?           @db.Decimal(10, 2)
  limit   Decimal?           @db.Decimal(10, 2)
  percent Decimal?           @db.Decimal(10, 2)

  created_at DateTime? @default(now())
  updated_at DateTime? @updatedAt

  @@unique([type, level, value])
  @@map("strategy_config")
}

model StrategyProgress {
  type    StrategyConfigType
  user    User               @relation("user", fields: [user_id], references: [id])
  user_id BigInt             @db.UnsignedBigInt

  amount Decimal @default(0)

  created_at DateTime? @default(now())
  updated_at DateTime? @updatedAt

  @@id([type, user_id])
  @@unique([type, user_id])
  @@map("strategy_progress")
}

enum StrategyConfigType {
  DIRECT
  UNILEVER
  BINARY
  RESIDUAL
}

model Order {
  id       BigInt @id @default(autoincrement()) @db.UnsignedBigInt
  order_id String
  user     User   @relation("user", fields: [user_id], references: [id])
  user_id  BigInt @db.UnsignedBigInt

  status                Status                  @default(init)
  createdAt             DateTime                @default(now())
  updatedAt             DateTime?               @updatedAt
  OrderItem             OrderItem[]             @relation("order")
  OrderItemDistribution OrderItemDistribution[] @relation("order")

  @@map("order")
}

model OrderItem {
  id       BigInt @id @default(autoincrement()) @db.UnsignedBigInt
  order    Order  @relation("order", fields: [order_id], references: [id])
  order_id BigInt @db.UnsignedBigInt

  product    Product @relation("product", fields: [product_id], references: [id])
  product_id BigInt  @db.UnsignedBigInt

  quantity Int     @default(1)
  amount   Decimal @db.Decimal(10, 2)

  createdAt             DateTime                @default(now())
  updatedAt             DateTime?               @updatedAt
  OrderItemDistribution OrderItemDistribution[] @relation("orderItem")

  @@map("order_item")
}

model OrderItemDistribution {
  id       BigInt             @id @default(autoincrement()) @db.UnsignedBigInt
  strategy StrategyType
  status   StrategyStatusType
  amount   Decimal
  percent  Decimal

  order    Order  @relation("order", fields: [order_id], references: [id])
  order_id BigInt @db.UnsignedBigInt

  orderItem     OrderItem @relation("orderItem", fields: [order_item_id], references: [id])
  order_item_id BigInt    @db.UnsignedBigInt

  user    User   @relation("user", fields: [user_id], references: [id])
  user_id BigInt @db.UnsignedBigInt

  created_at DateTime? @default(now())
  updated_at DateTime? @updatedAt

  @@unique([order_item_id, user_id, strategy], name: "order_item_distribution_idx")
  @@map("order_item_distribution")
}

enum products_yield_type {
  diary
  weekly
  monthly
  semiannual
  annual
}

enum users_profile {
  admin
  user
  admin_watch
}

enum users_position {
  left
  right
}

enum user_session {
  active
  inactive
}

enum Status {
  init
  pending
  payed
  done
  canceled
}

enum StrategyType {
  DIRECT
  UNILEVER
  BINARY
  RESIDUAL
}

enum StrategyStatusType {
  QUEUED
  ERROR
  DONE
}

enum WalletType {
  MAIN
}

enum BalanceDirectionType {
  CREDIT
  DEBIT
}
